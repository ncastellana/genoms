package antibody;

import basicUtils.Utils;
import errorUtils.ErrorThrower;

/**
 * This class represents a the alignment of a spectrum to a particular model.
 * 
 * @author natalie
 * 
 */
public class HMMAlignment {

	public class HMMAlignmentType {
		public static final int LEFT_ALIGN = 0;
		public static final int RIGHT_ALIGN = 1;
		public static final int UNKNOWN = 2;
	}

	// The spectrum aligned
	private MSAlignmentType SpectrumAlignment;

	// The SCALED MassShift of the spectrum to align to the SeedSequence
	private int MassShift;

	// VOLATILE variables that change when the model changes
	// The ML path (determined by Viterbi) for this spectrum
	private int[] MLPath;

	// Pretty string version of the MLPath, generated by
	// GatherConsensus.GetStateString
	private String PathString;

	// Score of this specturm aligned to the current HMM
	private double SpectrumAlignmentScore;

	private int[] ShiftedPRMs = null;
	private double[] ShiftedPRMScores;

	private int AlignmentType = HMMAlignmentType.UNKNOWN;;

	// private SpectrumNode ContainingNode;

	public int GetAlignmentType() {
		return this.AlignmentType;
	}

	/**
	 * Constructor for an empty alignment, assigned to a spectrum but with no
	 * alignment information
	 * 
	 * @param Spectrum
	 *            The spectrum for this alignment to the model
	 */
	public HMMAlignment(MSAlignmentType SpectrumAlignment, int AlignmentType) {
		// Make sure spectrum is not null
		if (SpectrumAlignment == null) {
			ErrorThrower.ThrowErrorCustum(ErrorThrower.CUSTOM_ERROR,
					"HMMAlignment - SpectrumAlignment is null");

		}
		this.SpectrumAlignment = SpectrumAlignment;
		SpectrumAlignment.GetSpectrumNode().HMMAnnotation = this;
		this.MLPath = null;
		this.PathString = "";
		this.AlignmentType = AlignmentType;

	}

	public static boolean IsGoodHMMAlignment(HMMAlignment A, SpectrumHMM M) {
		if (A.GetNumMatches() < AntibodyUtils.MIN_PEAKS_ALIGNED)
			return false;

		if (A.GetNumDeletes() >= A.GetNumMatches())
			return false;

		if (A.GetLargestRunDeletes() > Math.min(A.GetNumMatches(),
				AntibodyUtils.MIN_PEAKS_ALIGNED))
			return false;

		// double PercentDeletes =
		// ((double)(A.GetNumDeletes()))/A.GetPRMSpectrum().PRMs.length;
		// if(PercentDeletes >= 0.05)
		// return false;
		return true;
	}

	public void SetShiftedPRMs(double Tolerance) {
		int[] PRMs = this.GetPRMSpectrum().PRMs;
		double[] Scores = this.GetPRMSpectrum().PRMScores;
		int StartIndex = 0;

		if (this.AlignmentType == HMMAlignmentType.RIGHT_ALIGN) {
			while (PRMs[StartIndex] + this.MassShift < -1 * Tolerance
					* AntibodyUtils.MASS_SCALE)
				StartIndex++;

			this.ShiftedPRMs = new int[PRMs.length - StartIndex];
			this.ShiftedPRMScores = new double[this.ShiftedPRMs.length];
			for (int i = 0; i < this.ShiftedPRMs.length; ++i) {
				this.ShiftedPRMs[i] = PRMs[i + StartIndex] + this.MassShift;
				this.ShiftedPRMScores[i] = Scores[i + StartIndex];
			}
		} else if (this.AlignmentType == HMMAlignmentType.LEFT_ALIGN) {
			int EndIndex = 0;
			int SeqMass = AntibodyUtils.GetSeqMassScaled(this.SpectrumAlignment
					.GetAnchorSequence());
			// System.out.println("Shifting PRMS with max mass: " + SeqMass +
			// " from " + this.SpectrumAlignment.GetAnchorSequence());
			while (EndIndex < PRMs.length
					&& PRMs[EndIndex] + this.MassShift < SeqMass + Tolerance
							* AntibodyUtils.MASS_SCALE)
				EndIndex++;
			this.ShiftedPRMs = new int[EndIndex];
			this.ShiftedPRMScores = new double[EndIndex];

			for (int i = 0; i < this.ShiftedPRMs.length; ++i) {
				this.ShiftedPRMs[i] = PRMs[i] + this.MassShift;
				this.ShiftedPRMScores[i] = Scores[i];
			}
		} else {
			System.out
					.println("ERROR: Cannot create shifted PRMs for Unknown alignment type!!\n");
			this.ShiftedPRMs = PRMs;
			this.ShiftedPRMScores = Scores;
		}
	}

	/**
	 * Constructor for an alignment which is partially performed, the seed
	 * sequence is known so the Mass Shift can be determined, but no alignment
	 * info is determined
	 * 
	 * @param Spectrum
	 *            The spectrum of the alignment
	 * @param MassShift
	 *            The shift of the spectrum against the Spectrum
	 */
	public HMMAlignment(MSAlignmentType SpectrumAlignment, int MassShift,
			int AlignmentType, double Tolerance) {
		if (SpectrumAlignment == null) {
			ErrorThrower.ThrowErrorCustum(ErrorThrower.CUSTOM_ERROR,
					"HMMAlignment - SpectrumAlignment is null");
		}
		this.SpectrumAlignment = SpectrumAlignment;
		this.MassShift = MassShift;
		this.MLPath = null;
		this.PathString = "";
		this.AlignmentType = AlignmentType;
		this.SetShiftedPRMs(Tolerance);
	}

	/**
	 * Full constructor for HMMAlignment. The path string is constructed each
	 * time the MLPath is reset.
	 * 
	 * @param Spectrum
	 *            The spectrum in the alignment
	 * @param MassShift
	 *            The mass shift of the spectrum against the seed sequence
	 * @param MLPath
	 *            The path of the spectrum through the model
	 * @param AlignmentScore
	 *            The score of the path through the model
	 */
	public HMMAlignment(MSAlignmentType SpectrumAlignment, int MassShift,
			int[] MLPath, double AlignmentScore, SpectrumHMM Model,
			int AlignmentType, double Tolerance) {
		if (SpectrumAlignment == null) {
			ErrorThrower.ThrowErrorCustum(ErrorThrower.CUSTOM_ERROR,
					"HMMAlignment - SpectrumAlignment is null");
		}
		this.SpectrumAlignment = SpectrumAlignment;
		this.MassShift = MassShift;
		this.MLPath = MLPath;
		this.AlignmentType = AlignmentType;
		this.SpectrumAlignmentScore = AlignmentScore;

		this.PathString = Model.GetStateString(MLPath);
		this.SetShiftedPRMs(Tolerance);
	}

	public int GetMassShift() {
		return this.MassShift;
	}

	public int[] GetShiftedPRMs() {
		return this.ShiftedPRMs;
	}

	public double[] GetShiftedPRMScores() {
		return this.ShiftedPRMScores;
	}

	/**
	 * Whenver the alignment of this spectrum is updated, as in the case of a
	 * newly modified HMM, this method is used to update the Alignmetn info
	 * 
	 * @param MLPath
	 */
	public void UpdateAlignment(int[] MLPath, double AlignmentScore,
			SpectrumHMM Model, double Tolerance) {
		this.MLPath = MLPath;
		this.SpectrumAlignmentScore = AlignmentScore;
		this.PathString = Model.GetStateString(MLPath);
		if (this.ShiftedPRMs == null)
			this.SetShiftedPRMs(Tolerance);
	}

	/**
	 * Accessor for the path String
	 * 
	 * @return Returns the current Path string
	 */
	public String GetPathString() {
		return this.PathString;
	}

	public PRMSpectrum GetPRMSpectrum() {
		return this.SpectrumAlignment.GetSpectrum();
	}

	public MSAlignmentType GetMSAlignmentType() {
		return this.SpectrumAlignment;
	}

	public double GetPathScore() {
		return this.SpectrumAlignmentScore;
	}

	public int[] GetMLPath() {
		return this.MLPath;

	}

	public int GetNumMatches() {
		int Count = 0;
		for (int i = 0; i < this.PathString.length(); ++i) {
			if (this.PathString.charAt(i) == 's')
				Count += 1;
		}
		return Count;
	}

	public int GetNumDeletes() {
		int Count = 0;
		for (int i = 0; i < this.PathString.length(); ++i) {
			if (this.PathString.charAt(i) == 'd')
				Count += 1;
		}
		return Count;
	}

	public int GetLargestRunDeletes() {
		int Count = 0;
		int MaxCount = 0;
		for (int i = 0; i < this.PathString.length(); ++i) {
			if (this.PathString.charAt(i) == 's') {
				if (Count > MaxCount)
					MaxCount = Count;
				Count = 0;
			}
			if (this.PathString.charAt(i) == 'd')
				Count += 1;
		}
		if (Count > MaxCount)
			MaxCount = Count;
		return MaxCount;
	}

	public boolean MLPathSupports(int State) {
		for (int i = 0; i < this.MLPath.length; ++i) {
			if (this.MLPath[i] == State)
				return true;
		}
		return false;
	}

	/**
	 * This HMM alignment annotates each peak in the spectrum as being a
	 * 'Match', or an 'Insert'. This method filteres the spectrum to only
	 * include 'Match' peaks
	 * 
	 * @return Returns an int array of the MASS_SCALE scaled match peaks for
	 *         this HMMAlignment
	 */
	public int[] getAlignedPeaks() {
		int MLPathIndex = 0;
		int specIndex = 0;
		String[] pathEls = this.GetPathString().split(" ");
		int[] retSpec = new int[this.GetNumMatches()];

		for (int i = 0; i < this.ShiftedPRMs.length; ++i) {
			// This is a delete state, so increment the MLPathIndex, but not the
			// spectrum index
			while (MLPathIndex < pathEls.length
					&& (pathEls[MLPathIndex].charAt(0) == 'd' || pathEls[MLPathIndex]
							.charAt(0) == 'D'))
				MLPathIndex += 1;
			if (MLPathIndex >= pathEls.length)
				break;
			// We found a match state, so include this in the retSpec
			if (pathEls[MLPathIndex].charAt(0) == 's'
					|| pathEls[MLPathIndex].charAt(0) == 'S') {
				retSpec[specIndex] = this.ShiftedPRMs[i];
				MLPathIndex += 1;
				specIndex += 1;
			}
			// We found an insert state, so don't include this in the retSpec
			else if (pathEls[MLPathIndex].charAt(0) == 'i'
					|| pathEls[MLPathIndex].charAt(0) == 'I') {
				MLPathIndex += 1;
			}

		}

		// Sanity check
		if (specIndex != retSpec.length) {
			System.err
					.println("ERROR: Did not fill in all of the return spec!!");
			Utils.WaitForEnter();
		}
		return retSpec;
	}
}
